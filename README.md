# Отчет о выполнении задания  
Ссылка на задание: https://gist.github.com/pkonotopov/99e3576b975e2cbe051725972fd20429
## 1. Структура репозитория  
  * Папка data. Предназначена для хранения данных, которые будут загружены в БД.  
    * В существующих там файлах LinkTypes.txt, PostHistoryTypes.txt, PostTypes.txt, VoteTypes.txt хранятся данные для заполнения таблиц БД с одноименными названиями
    * В папку data требуется перенести архив данных из задания (подробнее см. пункт 2.1.1.)  
  * create_tables.sql - скрипт для создания таблиц БД
  * inserting_data.py - скрипт для заполнения БД
  * Q2.sql - скрипт запроса Q2 из задания
## 2. Инструкция по запуску
Для создания БД и работы с ней на компьютере должны быть установлены PostgreSQL, pgAdmin, Python.  
### 2.1. Подготовительные шаги
1. Скачайте архив данных, указанный в задании, и извлеките его в папку data в структуре данного репозитория
2. Настройте скрипт inserting_data.py с учетом имени пользователя и пароля, использующихся Вами для работы с PostgreSQL:
    * На 5 строке вместо your_name напишите имя пользователя
    * На 6 строке вместо your_password напишите пароль
    * Также Вы можете задать, из какого именно архива из задания будут взяты данные для заполненения БД (в задании приложены два архива). Для этого на 7 строке в кавычках пропишите относительный путь к выбранной папке с .xml файлами. По умолчанию указан архив dba.stackexchange.com

### 2.2. Инструкция по созданию БД и таблиц в ней
1. Создайте БД под названием "StackExchange". Один из способов, которым это можно сделать:  
    * Откройте pgAdmin
    * После авторизации нажмите правой кнопкой мыши на "Databases" в панели слева
    * Выберите "Create", затем - "Database"
    * В открывшемся окне введите в поле "Database" название создаваемой БД - "StackExchange"
    * Созданная БД отобразится в панели слева
2.  Для запуска SQL скрипта создания таблиц:
    * В панели слева выделите БД StackExchange, нажав на её название
    * Нажмите на значок Query Tool в верхней левой части окна pgAdmin - откроется поле для работы с запросами
    * Нажмите на значок папки (Open File) в левом верхнем углу поля и выберите файл create_tables.sql - откроется скрипт создания таблиц
    * Запустите create_tables.sql  
### 2.3. Инструкция по загрузке данных в БД
1. Откройте папку с файлом inserting_data.py в терминале. В Windows и Linux это можно сделать следующим способом:  
    * Откройте папку в проводнике  
    * Наведите курсор в любое место и нажмите правую кнопку мыши: в выпавшем окне нажмите на "Открыть в терминале"
2. В терминале выполните команду "python inserting_data.py"
### 2.4. Инструкция по выполнению запросов
Запустите Q2.sql по тому же алгоритму, как и запуск create_tables.sql

## 3. Вопросы, возникшие в ходе выполнения задания, и принятые решения
### 3.1. Общие вопросы
1. Не все таблицы из схемы БД, приложенной к заданию, отражены в дампе. Было решено создать в БД только таблицы, отраженные в дампе, а также добавить таблицы, описанные в пункте 2
2. Исходя из схемы БД, приложенной к заданию, поля некоторых таблиц являются внешними ключами, ссылающимися на первичные ключи таблиц PostHistoryTypes, PostTypes, VoteTypes, LinkTypes. Поэтому было решено добавить эти таблицы в создаваемую БД, несмотря на то что данных для них нет в дампе. Указанные таблицы были заполнены на основе информации с сайта https://meta.stackexchange.com/questions/2677/database-schema-documentation-for-the-public-data-dump-and-sede/2678#2678, ссылка на который приложена в задании.  
Введение этих четырех таблиц повышает степень нормализации и структурированность данных, делая схему БД более универсальной и удобной для работы.
3. На этапе заполнения БД данными из дампа возникла проблема с парсингом апострофов в текстовых полях, так как они воспринимались не как часть строки, а как служебный символ для обозначения границ строки. Для решения проблемы была использована встроенная библиотека Python ElementTree и написана функция замены апострофов на "&apos;".
4. При заполнении таблицы posts возникла проблема, связанная с тем, что поля accepted_answer_id и parent_id ссылаются на саму же таблицу. Поэтому ее заполнение производится через два последовательных цикла for (в отличие от вставки данных в остальные таблицы, функции заполнения которых содержат только по одному циклу):
    * В первом цикле заполняются все поля таблицы posts, кроме accepted_answer_id и parent_id
    * Во втором цикле заполняются поля accepted_answer_id и parent_id
### 3.2. Рассуждения, касающиеся запросов
#### Q1. 
В рамках установленных сроков выполнения задания у меня не было времени полностью реализовать данный запрос, но есть несколько идей для его написания:
1. Возможно, запрос Q1 будет более оптимален и удобен в составлении, если вместо поля tags таблицы posts ввести дополнительную таблицу M2M_posts_tags для реализации связи "многие ко многим" между таблицами posts и tags. Новая таблица должна содержать 2 поля: post_id и tag_id. Таким образом, значению поля tags в одной строке таблицы posts может соответствовать от 0 до нескольких строк в таблице M2M_posts_tags.  
Такое решение повысит структурированность данных и упростит поиск и сопоставление постов и тегов.
2. В ходе выполнения запроса будет создана временная таблица для учета того, в какие пары тегов встречаются совместно и в каких постах. Табилца должна содеражть три поля: post_id, tag_id_1 (id первого тега в паре), tag_id_2 (id второго тега в паре)
3. В основе запроса Q1 будет оконная функция, работающая с временной таблицей из предыдущего пункта
#### Q2. 
Было установлено, что в БД нет строк, соответствующих постам-ответам, у которых значение поля tags было бы не null. Такой вывод следует из того, что запрос  
  
SELECT *  
FROM posts  
WHERE (post_type_id = 2) AND (tags IS NOT NULL)  
  
возвращает 0 строк.  
Поэтому для выполнения требования задания "ответ должен иметь тег "postgresql" " было решено принять договоренность, что пост-ответ имеет такой же тег, как соответствующий ему пост-вопрос.
